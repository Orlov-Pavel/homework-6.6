# Домашнее задание к занятию "6.6. Troubleshooting"
1. Cписок операций для остановки запроса пользователя:
   1. Получить список операций при помощи db.currentOp(), найти в списке нужную операцию и взять её id
   2. Прервать операцию при помощи db.killOp()  
   
   Для предотварщения такой ситуации можно использовать поле maxTimeMS при запуске операции, что ограничит время её выполнения, либо оптимизировать запрос.
2. Судя по всему проблема появляется из-за того что в одну и туже секунду истёкшими становятся огромное кол-во ключей. Redis запускает автоматическую очистку ключей, после очистки видит что истёкших ключей по прежнему много и запускает очистку повторно, при этом блокируются операции записи для уменьшения количества одновременно истекающих ключей.
3. Предполагаю что это могло произойти из-за того, что в связи с ростом числа записей в таблице, запрос начал выполняться слишком долго и соединение обрывается по таймауту. Можно проверить сделав Inspect на запрос и сравнить время выполнения с таймаутом, либо как вариант увеличить таймаут на ожидание ответа.  
Попробовать решить проблему можно несколькими способами:  
   * Оптимизировать запрос
   * Построить более эффективные индексы
   * Разделить таблицу, либо сделать её срез
   * Увеличить таймаут ожидания в запросе
   * Перейти на более производительную, при работе с большими объёмами данных, СУБД
4. Судя по всему БД пытается выйти за пределы объёма оперативной памяти хоста.  
   Можно попробовать несколько вариантов решить проблему:
   * Увеличить объём оперативной памяти
   * Увеличить объём swap - что может негативно сказаться на производительности
   * Обратить внимание на параметры напрямую связанные с использованием оперативной памяти хоста. Такие параметры как shared_buffer, effective_cache_size. Настроить эти параметры так, чтобы система не пыталась выйти за пределы достпной на сервере оперативной памяти